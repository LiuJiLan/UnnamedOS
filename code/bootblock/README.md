# bootblock

- 第一版变量名、函数名尽量与xv6中保持一致

# 1.存在的问题

## 只能用在使用flash的平台
- 尝试把启动栈栈顶设置在0x803FFFF0, 但是报跳转太远, 所以栈是在临近部分开的
- 但这就要求, 栈所在的内存(或者说内存映射空间)必须可写
- qemu中设置的就是ROM, 所以跳转不了C函数

# 2.测试的问题

## 暂未上板子

## qemu测试 —— 二次跳转
- qemu测试暂时把bootblack放到了0x80200000处, 测试用的elf文件放在了0x80201000处
- qemu使用-bios none选项在0x1000运行一段后(此处还是运行了一部分程序的)跳转到0x80000000处
- 因为我暂时不想探究这个, 就在写了一个简单的汇编程序在0x80000000处, 再转跳到0x80200000处
- 设想的程序是在板子的flash上跑, 这只是用qemu做一个测试, 二次跳转一下也无所谓

## qemu测试 —— 测试用程序
- 测试程序是RVOS, 程序入口在0x80000000, 由bootblack由0x80201000加载到位
- (程序入口这个值是由测试用elf文件决定的, 也可以是其他的值, 由bootblock去处理)
- 测试程序内容是向uart串口输出"Hello, RVOS!\n"

## qemu测试 —— 为啥testtestbios.bin不放在0x80000000
- 因为测试用的elf文件的会被加载到0x80000000, 而bootblack的栈就在其放置起点位置附近
- 如果testtestbios.bin放在0x80000000处, bootblock的栈内容会被覆盖
- (如果elf文件大, 其实不止栈, 代码也会一起被覆盖, 这将会引发unexpectable behavior)
