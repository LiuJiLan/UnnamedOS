# bootblock

- 第一版变量名、函数名尽量与xv6中保持一致

# 1.存在的问题

## 只能用在使用flash的平台
- 尝试把启动栈栈顶设置在0x803FFFF0, 但是报跳转太远, 所以栈是在临近部分开的
- 但这就要求, 栈所在的内存(或者说内存映射空间)必须可写
- qemu中设置的就是ROM, 所以跳转不了C函数

# 2.测试的问题

## 暂未上板子

## qemu测试 —— 二次跳转
- qemu测试暂时把bootblack放到了0x80200000处, 测试用的elf文件放在了0x80201000处
- qemu使用-bios none选项在0x1000运行一段后(此处还是运行了一部分程序的)跳转到0x80000000处
- 因为我暂时不想探究这个, 就在写了一个简单的汇编程序在0x80000000处, 再转跳到0x80200000处
- 设想的程序是在板子的flash上跑, 这只是用qemu做一个测试, 二次跳转一下也无所谓

## qemu测试 —— 测试用程序
- 测试程序是RVOS, 程序入口在0x80000000, 由bootblack由0x80201000加载到位
- (程序入口这个值是由测试用elf文件决定的, 也可以是其他的值, 由bootblock去处理)
- 测试程序内容是向uart串口输出"Hello, RVOS!\n"

## qemu测试 —— 为啥testbios.bin不放在0x80000000
- 因为测试用的elf文件的会被加载到0x80000000, 而bootblack的栈就在其放置起点位置附近
- 如果testtestbios.bin放在0x80000000处, bootblock的栈内容会被覆盖
- (如果elf文件大, 其实不止栈, 代码也会一起被覆盖, 这将会引发unexpectable behavior)
- 实际情况不用担心这个问题, 因为实际运行的代码和栈都会在由flash映射到内存的空间, 而不是SRAM映射到内存的空间

# 后记

## 奇葩的li、la、j与jr
- li与la, 两个伪指令, 一个用来加载立即数, 一个用来加载地址
- 但la的工作原理其实利用了PC的值, 而PC的值又是编译器在编译时推断的
- 这在某些情况下非常明显, 当我在测试分页机制的时候, 代码实际运行在0x8020_0000附近(物理地址)
- 但我在编译的时候给的是虚拟地址, 然后这个时候编译器就会“猜”我想la的0x8020_0000很远(我当时在编一个循环来观测)
- 这个时候就编译报错```Error: offset too large```, 但我改成用li又可以了。
- j和jr, 两个伪指令用于转跳, j的范围真的挺小的, 尽量还是写个寄存器然后jr吧

