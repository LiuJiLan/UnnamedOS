# xv6-riscv

## 操作系统构成
参考比赛官网去年["内核赛要求"部分](https://os.educg.net/2021CSCC)
*   启动和系统初始化
*   内存管理
*   进程管理和中断异常机制
*   系统调用
*   文件系统
*   命令解释程序

我个人选择做一些更改:
*   启动和系统初始化
*   内存管理
*   进程管理
*   中断异常机制
*   系统调用
*   文件系统

命令解释程序我将其归为用户程序部分

---

# 启动和系统初始化

## 启动流程
entry.S -> start.c -> main.c  

## 与xv6的区别
* **cpu启动顺序**  
> risc-v下hart(类似于x86体系下的cpu)可以认为是在同一时间同时启动。  
> 而x86中首先由主处理器于`0x7c00`处启动, 运行一段汇编代码并设置好栈(以运行C语言代码), 随后便进入到`main.c`之中, 此时内核运行`0x10_0000`。  
> 在`main.c`之中首先于`startothers()`将用于其他cpu启动的汇编代码移动到`0x7000`, 随后通过IPI启动其他核。  
> xv6-riscv中, 由于risc-v的体系结构特性则去掉了通过ipi启动的方式。  
> 甚至由于设计问题, 还没有开启ipi功能(即hart的软件中断)。

## entry.S
设置了每个hart单独使用的stack。  
此处留下几个问题:
1.   检查了xv6-riscv的页表映射, 发现是由0x8000_0000 -> 0x8000_0000。由于x86中xv6也是放在虚存的这个位置, 怀疑是为了和旧版本兼容(但也不排除就是为了避免S态和M态的栈问题), 这导致从entry.S开始整个内核始终在使用同一个栈, 而这对大部分risc-v内核而言是不现实的, 这导致M态和S态的栈位于同一位置, 从而避免了由S态trap入M态时的栈位置转化。
2.   我们之后讨论到底我们改使用几个栈, 以及是否像我之前尝试的那样使用多个栈空间(临时空间 + 多个临时压栈空间)
3.   但相同的是运行时栈, M态和S态用于维护C语言程序正常运行的栈是同一个, 但是当转跳到S态后, xv6-riscv没有再在M态设计使用C语言(见kernelvec.S中的timervec), 由此我们必须得讨论中断/异常设计对栈设计时的影响。
4.   我们确实可以讨论的一个话题是, 我们是否有能力去减少M态初始化时的运行时栈。例如: xv6-riscv在main.c中设计了一个公用的started参数, 当0号hart(也就是hart id为0, 也就是mhartid寄存器为0的hart)将started置1后才开始运行。由于要一直判断started是否为0, 此处其他核的循环是普通的死循环, 没有用到wfi指令的特性(由于ISA规范, wfi的最简单实现可能是nop, 如果这样并不能提升死循环的功耗)。我们可以在从hart(借用x86主从CPU的概念)设置栈之前开启mie下的软中断位(mstatus中仍然关中断, 一是由于这样不会影响软中断对此hart的唤醒, 二是避免引发中断陷入我们还未初始化的mtvec), 我们可以采取类似xv6的方法在main.c中使用ipi去唤醒从hart。**关于这条我们有两点要补充。**
5.   risc-v体系下没有绝对的主从处理器之分(在软件上, 硬件设计上例如qemu模拟的那块芯片就是0号和其他不一样), 但我们会使用0号处理器来主导整个启动进程, 这是因为在手册中0号处理器是绝对要求实现的。
6.   即使要与xv6的过程类似, 我们也不能将发送ipi唤醒的过程放在main.c中(只是考虑ipi唤醒启动, 毕竟ipi在设计上还有通知其他处理器刷新页表的软件作用, PS. 不一定要用ipi来实现提醒其他处理器刷新页表), main.c已经位于S态, 考虑到日后别人对我们系统的移植可能基于SBI, 在这样的情况下我们应该让所有hart几乎同一时间进入S态。**又得讨论核的唤醒顺序问题**, 但我们可以在进入S态之后再次设计一套wfi等待循环(这次的目的不再是节约运行时栈, 而是1.考虑到0号在主导启动, 所以0号可能是最后进入S态的, 因为它要一个一个确保唤醒其他hart后才自己进入S态。2.减少普通死循环的时间, 尽管如果我们按照xv6-riscv的思路移植又回遇到0号要唤醒其他所以会在唤醒其他hart之后才运行`userinit()`, 而其他核又要等待`userinit()`运行完之后才开始初始化, 相当于其他核又要等0号, 所以我们总要有普通死循环去等, 我们只是减少了这个的时间,**所以引出以下问题**)
7.   是否能通过我们的代码设计使6中的普通死循环时间尽量的短, 或者有没有方法避免出现这种等待?
8.   使用这种唤醒的机制回不回导致启动时间的增加?

---
